<!doctype html>
<html>
  <head>
    <meta charset="utf-8"/>
    <style>
      *{
        box-sizing:border-box;
      }
      body {
        margin:0;
        padding:0;
        background: brown;
      }
      #desktop{
        position: relative;;
        height:600px;  
        width:800px;  
      }
      #preview,
      #photo{
        position: absolute;
        height:100%;  
        width:100%;  
        top:0px;
        left:0px;
      }
      #photo{
        /*display: none;*/
      }
    </style>
  </head>
  <body>
    <div id="desktop">
      <img id="photo" src="labirynt Hugo.jpg"/>
      <canvas id="preview" width="800" height="600"/>
    </div>
    <label for="rows">rows:</label><input type=number id="rows" value=25>
    <label for="columns">columns:</label><input type=number id="columns" value=38>
    <span id="status"></span>
  </body>
  <script type="text/javascript" src="lib.js"></script>
  <script type="text/javascript">

const photo = document.getElementById('photo');
const preview = document.getElementById('preview');
const ctx = preview.getContext('2d');
function drawDot(color,p){
  ctx.strokeStyle=color;
  ctx.beginPath();
  ctx.rect(p.x-1, p.y-1,3,3);
  ctx.stroke();
}
function analyze(){
  ctx.drawImage(
    photo, 
    0, 0, photo.width, photo.height
  );
  const imageData=ctx.getImageData(0,0,preview.width,preview.height);
  const data = imageData.data;
  const cloned = new Uint8ClampedArray(data);
  const get = (x,y) => {
    const pos=y*preview.width*4+4*x;
    const colors = [cloned[pos+0],cloned[pos+1],cloned[pos+2]]
    return colors;
  }
  const WX = [
    [-1, 0, 1],
    [-2, 0, 2],
    [-1, 0, 1],
  ];
  const WY = WX.map((row,i)=>row.map((v,j)=>WX[j][i]))
  const W=[WX,WY];
  const es = [];
  const xy2pos = (x,y)=>(y*preview.width+x)*4;
  for(let y=1;y+1<preview.height;++y){
    for(let x=1;x+1<preview.width;++x){
      const pos=xy2pos(x,y);
      let L=[[0,0,0],[0,0,0]];
      for(let dx=-1;dx<=1;++dx){
        for(let dy=-1;dy<=1;++dy){
          const n=get(x+dx,y+dy);
          W.forEach((w,i)=>{
            const s=w[1+dy][1+dx];
            n.forEach((v,j)=> {L[i][j]+=s*v})
          })
        }
      }
      const e = max(L[0].map((l,i)=> Math.sqrt(l**2+L[1][i]**2)) );
      es.push(e);
      for(let i=0;i<3;++i){
        data[pos+i]=e;
      }
    }
  }
  const threshold = split(es).threshold;
  for(let y=1;y+1<preview.height;++y){
    for(let x=1;x+1<preview.width;++x){
      const pos=xy2pos(x,y);
      for(let i=0;i<3;++i){
        data[pos+i]=data[pos+i]>threshold?255:0;
      } 
    }
  }
  let todo=[];
  for(let y=preview.height>>2;y<preview.height*3>>2;++y){
    for(let x=preview.width>>2;x<preview.width*3>>2;++x){
      const pos=xy2pos(x,y);
      if(data[pos+0]){
        data[pos+1]=0;
        todo.push({x,y});
      }
    }
  }

  let min_x = Array.from({length:preview.height},()=>+Infinity)
  let max_x = Array.from({length:preview.height},()=>-Infinity)
  let min_y = Array.from({length:preview.width},()=>+Infinity)
  let max_y = Array.from({length:preview.width},()=>-Infinity)
  while(todo.length){
    const {x,y}=todo.pop();
    if(x<min_x[y])min_x[y]=x;
    if(max_x[y]<x)max_x[y]=x;
    if(y<min_y[x])min_y[x]=y;
    if(max_y[x]<y)max_y[x]=y;
    for(let dx=-2;dx<=2;++dx){
      const x2=x+dx;
      if(0<=x2 && x2<preview.width){
        for(let dy=-2;dy<=2;++dy){
          const y2=y+dy;
          if(0<=y2 && y2<preview.height){
            const pos=xy2pos(x2,y2);
            if(data[pos+0]&&data[pos+1]){
              data[pos+1]=0;
              todo.push({x:x2,y:y2});
            }
          }
        }
      }
    }
  }
  const border=[];
  const submit=(x,y)=>{
    const pos = xy2pos(x,y);
    if(data[pos+2]){
      data[pos+2]=0;
      border.push({x,y});
    }
  }
  min_x.forEach((x,y)=>{if(x!=+Infinity){submit(x,y)}})
  max_x.forEach((x,y)=>{if(x!=-Infinity){submit(x,y)}})
  min_y.forEach((y,x)=>{if(y!=+Infinity){submit(x,y)}})
  max_y.forEach((y,x)=>{if(y!=-Infinity){submit(x,y)}})
  for(let y=1;y+1<preview.height;++y){
    for(let x=1;x+1<preview.width;++x){
      const pos=xy2pos(x,y);
      if(!data[pos+0]||data[pos+1]||data[pos+2]){
        data[pos+0]=data[pos+1]=data[pos+2]=0;
      }
    }
  }
  console.log(border.length);
  border.sort((a,b)=> Math.atan2(a.y-preview.height/2,a.x-preview.width/2)-Math.atan2(b.y-preview.height/2,b.x-preview.width/2))
  const lowest=-preview.width;
  const highest=Math.sqrt(preview.width**2+preview.height**2);
  const span=highest-lowest;
  const huogh=Array.from({length:180},(_,i)=>{
    const a=Math.PI*i/180;
    const c=Math.cos(a);
    const s=Math.sin(a);
    const shadows=Array.from({length:span},()=>0)
    border.forEach(({x,y})=>shadows[ Math.round(x*c+y*s) - lowest]++)
    return shadows;
  })
  for(let y=0;y<preview.height;++y){
    for(let x=0;x<preview.width;++x){
      const pos=xy2pos(x,y);
      data[pos+2]=huogh[Math.floor(y*180/preview.height)][Math.floor(x*span/preview.width)]
    }
  }
  const localOptima=[];
  huogh.forEach((offsets,deg)=>offsets.forEach((cnt,off)=>{
    if(cnt<2){
      return;
    }
    for(let dd=-3;dd<=3;++dd){
      let deg2=deg+dd;
      if(deg2<0)deg2+=180;
      if(180<=deg2)deg2-=180;
      for(let doff=-5;doff<=5;++doff){
        const off2=off+doff;
        if(0<=off2 && off2<span){
          if(cnt<huogh[deg2][off2]){
            return;
          }
        }
      }
    }
    localOptima.push({deg,off});
  }))
  localOptima.sort((a,b)=>huogh[a.deg][a.off]-huogh[b.deg][b.off])
  let sides=[];
  for(let i=0;i<4;++i){
    do{
      const best=localOptima.pop();
      if(sides.some((v)=> Math.abs(v.off-best.off)<10 && modDist(v.deg,best.deg,180)<10  )){
        continue;
      }
      const a=Math.PI*best.deg/180;
      sides.push({
        ...best,
        a,
        y:Math.sin(a),
        x:Math.cos(a),
      });
    }while(false)
  }
  console.log(sides);
  for(let y=0;y<preview.height;++y){
    for(let x=0;x<preview.width;++x){
      if(sides.some((side)=> Math.abs(x*side.x+y*side.y-(side.off+lowest))<=1)){
        const pos=xy2pos(x,y);
        data[pos+1]=255;
      }
    }
  }
  ctx.putImageData(imageData,0,0)
}
photo.addEventListener('load',()=>{
  analyze();
})
  </script>
</html>