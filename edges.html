<!doctype html>
<html>
  <head>
    <meta charset="utf-8"/>
    <style>
      *{
        box-sizing:border-box;
      }
      body {
        margin:0;
        padding:0;
        background: brown;
      }
      #desktop{
        position: relative;;
        height:600px;  
        width:800px;  
      }
      #preview,
      #photo{
        position: absolute;
        height:100%;  
        width:100%;  
        top:0px;
        left:0px;
      }
      #photo{
        /*display: none;*/
      }
    </style>
  </head>
  <body>
    <div id="desktop">
      <img id="photo" src="labirynt Hugo.jpg"/>
      <canvas id="preview" width="800" height="600"/>
    </div>
    <label for="rows">rows:</label><input type=number id="rows" value=25>
    <label for="columns">columns:</label><input type=number id="columns" value=38>
    <span id="status"></span>
  </body>
  <script type="text/javascript" src="lib.js"></script>
  <script type="text/javascript">

const photo = document.getElementById('photo');
const preview = document.getElementById('preview');
const ctx = preview.getContext('2d');
function drawDot(color,p){
  ctx.strokeStyle=color;
  ctx.beginPath();
  ctx.rect(p.x-1, p.y-1,3,3);
  ctx.stroke();
}
function drawEdges(){
  ctx.drawImage(
    photo, 
    0, 0, photo.width, photo.height
  );
  // According to Chorme's profiler getting preview.width takes a lot of time
  const size={x:preview.width,y:preview.height};

  const imageData=ctx.getImageData(0,0,size.x,size.y);
  const data = imageData.data;
  const cloned = new Uint8ClampedArray(data);
  const get = (x,y) => {
    const pos=y*size.x*4+4*x;
    const colors = [cloned[pos+0],cloned[pos+1],cloned[pos+2]]
    return colors;
  }
  const WX = [
    [-1, 0, 1],
    [-2, 0, 2],
    [-1, 0, 1],
  ];
  const WY = WX.map((row,i)=>row.map((v,j)=>WX[j][i]))
  const W=[WX,WY];
  const es = [];
  const xy2pos = (x,y)=>(y*size.x+x)*4;
  for(let y=1;y+1<size.y;++y){
    for(let x=1;x+1<size.x;++x){
      const pos=xy2pos(x,y);
      let L=[[0,0,0],[0,0,0]];
      for(let dx=-1;dx<=1;++dx){
        for(let dy=-1;dy<=1;++dy){
          const n=get(x+dx,y+dy);
          W.forEach((w,i)=>{
            const s=w[1+dy][1+dx];
            n.forEach((v,j)=> {L[i][j]+=s*v})
          })
        }
      }
      const e = max(L[0].map((l,i)=> Math.sqrt(l**2+L[1][i]**2)) );
      es.push(e);
      for(let i=0;i<3;++i){
        data[pos+i]=e;
      }
    }
  }
  return {
    size,
    imageData,
    data,
    es,
    xy2pos,
  }
}
function getCorners(){
  const {size,imageData,data,es,xy2pos}=drawEdges();
  const threshold = split(es).threshold;
  console.log(`threshold ${threshold}`);
  let above=0;
  for(let y=1;y+1<size.y;++y){
    for(let x=1;x+1<size.x;++x){
      const pos=xy2pos(x,y);
      for(let i=0;i<3;++i){
        const isAbove=data[pos+i]>threshold;
        above+=isAbove;
        data[pos+i]=255*isAbove;
      } 
    }
  }
  console.log(`above ${above}`)
  let todo=[];
  for(let y=size.y>>2;y<size.y*3>>2;++y){
    for(let x=size.x>>2;x<size.x*3>>2;++x){
      const pos=xy2pos(x,y);
      if(data[pos+0]){
        data[pos+1]=0;
        todo.push({x,y});
      }
    }
  }

  let min_x = Array.from({length:size.y},()=>+Infinity)
  let max_x = Array.from({length:size.y},()=>-Infinity)
  let min_y = Array.from({length:size.x},()=>+Infinity)
  let max_y = Array.from({length:size.x},()=>-Infinity)
  let processed=0;
  while(todo.length){
    processed++;
    const {x,y}=todo.pop();
    if(x<min_x[y])min_x[y]=x;
    if(max_x[y]<x)max_x[y]=x;
    if(y<min_y[x])min_y[x]=y;
    if(max_y[x]<y)max_y[x]=y;
    for(let dx=-2;dx<=2;++dx){
      const x2=x+dx;
      if(0<=x2 && x2<size.x){
        for(let dy=-2;dy<=2;++dy){
          const y2=y+dy;
          if(0<=y2 && y2<size.y){
            const pos=xy2pos(x2,y2);
            if(data[pos+0]&&data[pos+1]){
              data[pos+1]=0;
              todo.push({x:x2,y:y2});
            }
          }
        }
      }
    }
  }
  console.log(`processed ${processed}`);
  const border=[];
  const submit=(x,y)=>{
    const pos = xy2pos(x,y);
    if(data[pos+2]){
      data[pos+2]=0;
      border.push({x,y});
    }
  }
  min_x.forEach((x,y)=>{if(x!=+Infinity){submit(x,y)}})
  max_x.forEach((x,y)=>{if(x!=-Infinity){submit(x,y)}})
  min_y.forEach((y,x)=>{if(y!=+Infinity){submit(x,y)}})
  max_y.forEach((y,x)=>{if(y!=-Infinity){submit(x,y)}})
  for(let y=1;y+1<size.y;++y){
    for(let x=1;x+1<size.x;++x){
      const pos=xy2pos(x,y);
      if(!data[pos+0]||data[pos+1]||data[pos+2]){
        data[pos+0]=data[pos+1]=data[pos+2]=0;
      }
    }
  }
  console.log(border.length);
  border.sort((a,b)=> Math.atan2(a.y-size.y/2,a.x-size.x/2)-Math.atan2(b.y-size.y/2,b.x-size.x/2))
  const diagonal=Math.sqrt(size.x**2+size.y**2);
  const lowest=-size.x;
  const highest=diagonal;
  const span=highest-lowest;
  const huogh=Array.from({length:180},(_,i)=>{
    const a=Math.PI*i/180;
    const c=Math.cos(a);
    const s=Math.sin(a);
    const shadows=Array.from({length:span},()=>0)
    border.forEach(({x,y})=>{
      const projection=x*c+y*s;
      console.assert(lowest<=projection && projection<=highest); 
      shadows[Math.round(projection)  - lowest]++;
    })
    return shadows;
  })
  for(let y=0;y<size.y;++y){
    for(let x=0;x<size.x;++x){
      const pos=xy2pos(x,y);
      data[pos+2]=huogh[Math.floor(y*180/size.y)][Math.floor(x*span/size.x)]
    }
  }
  const localOptima=[];
  const mirrorOff = (off) => -(off+lowest)-lowest;
  {
    const DEG_DIFF=3;
    const OFF_DIFF=5;
    huogh.forEach((offsets,deg)=>offsets.forEach((cnt,off)=>{
      if(cnt<2){
        return;
      }
      for(let dd=-DEG_DIFF;dd<=DEG_DIFF;++dd){
        let deg2=deg+dd;
        let mirror=false;
        if(deg2<0){
          deg2+=180;
          mirror=true;
        }
        if(180<=deg2){
          deg2-=180;
          mirror=true;
        }
        for(let doff=-OFF_DIFF;doff<=OFF_DIFF;++doff){
          let off2=off+doff;
          if(mirror){
            off2=mirrorOff(off2);
          }
          if(0<=off2 && off2<span){
            if(cnt<huogh[deg2][off2]){
              return;
            }
          }
        }
      }
      const pos=xy2pos(Math.floor(off*size.x/span),Math.floor(deg*size.y/180));
      // data[pos+0]=data[pos+2];
      data[pos+0]=huogh[deg][off];
      data[pos+2]=0;
      localOptima.push({deg,off,cnt});
    }))
  }
  
  localOptima.sort((a,b)=>a.cnt-b.cnt)
  let sides=[];
  const SUPPRESS_DEG=10;
  const SUPPRESS_OFF=10;
  for(let i=0;i<4;++i){
    while(localOptima.length){
      const best=localOptima.pop();
      if(!sides.some((v,j)=> {
        let degDiff=Math.abs(v.deg-best.deg);
        let offDiff=Math.abs(v.off-best.off);
        if(degDiff>90){
          degDiff=180-degDiff;
          offDiff=Math.abs(v.off-mirrorOff(best.off))
        }
        console.log(i,j,degDiff,offDiff);
        return degDiff < SUPPRESS_DEG && offDiff<SUPPRESS_OFF
      })){
        sides.push(best);
        break;
      }
    }
  }
  sides = sides.map(side => {
    const a=Math.PI*side.deg/180;
    return ({
      off:side.off+lowest,
      a,
      y:Math.sin(a),
      x:Math.cos(a),
    });
  });
  console.log(sides);
  for(let y=0;y<size.y;++y){
    for(let x=0;x<size.x;++x){
      if(sides.some((side)=> Math.abs(x*side.x+y*side.y-side.off)<1)){
        const pos=xy2pos(x,y);
        // data[pos+1]=255;
      }
    }
  }
  
  for(let iter=0;iter<3;++iter){
    let sidesSamples=sides.map(()=>[])
    border.forEach(({x,y})=>{
      const nearestI=sides.map((side,i)=> [Math.abs(x*side.x+y*side.y-side.off),i]).sort((a,b)=>a[0]-b[0])[0][1];
      sidesSamples[nearestI].push(({x,y}));
      const pos=xy2pos(x,y);
      const color=[[255,255,255],[255,0,0],[0,255,255],[255,0,255]][nearestI];
      for(let i=0;i<3;++i)data[pos+i]=color[i];
    })
    const newSides=sidesSamples.map(optimalLine);
    console.log(`refining ${iter}`)
    newSides.forEach((newSide,i)=>{
      console.log(`${newSide.a} ${newSide.off} was ${sides[i].a} ${sides[i].off}`);
    })
    sides=newSides; 
  }
  const center={x:size.x/2,y:size.y/2};
  sides=sides.map(side=>{
    const off=side.off-scalar(side,center)
    const a = off<0 ? side.a+Math.PI: side.a;
    return [a,side];
  }).sort((a,b)=>a[0]-b[0]).map(a=>a[1])

  for(let y=0;y<size.y;++y){
    for(let x=0;x<size.x;++x){
      const nearestI=sides.findIndex((side)=> Math.abs(x*side.x+y*side.y-side.off)<1);
      if(-1<nearestI){
        const pos=xy2pos(x,y);
        const color=[[255,255,255],[255,0,0],[0,255,255],[255,0,255]][nearestI];
        for(let i=0;i<3;++i)data[pos+i]=color[i];
      }
    }
  }
  const corners=sides.map((side,i)=>{
    const next=sides[i+1&3];
    // x * side.x + y * side.y = side.off
    // x * next.x + y * next.y = next.off
    const A = [
      [side.x, side.y],
      [next.x, next.y],
    ];
    const b = [
      side.off,
      next.off,
    ];
    const [x,y]=solve(A,b);
    return {x,y};
  });
  ctx.putImageData(imageData,0,0);
  corners.forEach(corner=>{
    drawDot('green',corner);
  });
  console.log(corners)
  //Don't full ourselves that we know which side is which...
  //All we know they are ordered by angle, but the list can be "rotated".
  //To test for robustness, we can rotate the list random number of times.
  //for(let i=0;i<3;++i){
  //  corners.push(corners.shift());
  //}
  return corners;
}
function project(understanding,p){
  const C=understanding.u.z*p.x+understanding.v.z*p.y+1;
  if(C<=0)return {x:NaN,y:NaN};
  return {
    x: (understanding.u.x*p.x+understanding.v.x*p.y+understanding.o.x)/C,
    y: (understanding.u.y*p.x+understanding.v.y*p.y+understanding.o.y)/C,
  }
}
function invert(A){
  let A_inv=A.map(()=>A.map(()=>0));
  for(let i=0;i<A.length;i++){
    solve(A,A.map((_,j)=>i==j?1:0)).forEach((v,j)=>A_inv[j][i]=v)
  }
  return A_inv;
}
function vector_mul_vector (a,b) {
  return a.reduce((sum,v,i)=>sum+v*b[i],0);
}
function matrix_mul_vector(A,v){
  return A.map(row=>vector_mul_vector(row,v));
}
function getMatrices(understanding){
  const A = [
    [understanding.u.x,understanding.v.x,understanding.o.x],
    [understanding.u.y,understanding.v.y,understanding.o.y],
    [understanding.u.z,understanding.v.z,1],
  ];
  const A_inv=invert(A);
  return {A,A_inv};
}
function toIJ(A_inv,ip){
  const h=matrix_mul_vector(A_inv,[ip.x,ip.y,1]);
  return {x:h[0]/h[2],y:h[1]/h[2]};
}
function understand(rect_size,clicked_points){
  let ij=[
    [0,0],
    [0,rect_size.y],
    [rect_size.x,rect_size.y],
    [rect_size.x,0],
  ];
  let A=[];
  let b=[];
  for(var t=0;t<4;++t){
    const x=clicked_points[t].x;
    const y=clicked_points[t].y;
    const i=ij[t][0];
    const j=ij[t][1];
    //  u.x*i  + v.x*j + o.x = (u.z*i + v.z*j + 1)*clicked_point.x
    //  u.y*i  + v.y*j + o.y = (u.z*i + v.z*j + 1)*clicked_point.y
    //      u.x, u.y,  u.z, v.x, v.y,  v.z, o.x, o.y
    A.push([  i,   0, -i*x,   j,   0, -j*x,   1,   0  ] );
    b.push(x);
    A.push([  0,   i, -i*y,   0,   j, -j*y,   0,   1  ] );
    b.push(y);
  }
  const s=solve(A,b);
  const vectors = {
    u:{x: s[0], y:s[1], z:s[2]},
    v:{x: s[3], y:s[4], z:s[5]},
    o:{x: s[6], y:s[7]},
  }
  return {
    ...getMatrices(vectors),
    vectors,
  }
}
function getGridSize(corners){
  // first, we don't know how many rows and columns are there, so we will just pretend it's 1x1
  const simple= understand({x:1,y:1},corners);
  const {imageData,data,xy2pos,size}=drawEdges();
  ctx.putImageData(imageData,0,0);
  preview.addEventListener('mousemove',(e)=>{
    const p={x:e.offsetX,y:e.offsetY};
    const ij=toIJ(simple.A_inv,p);

    // document.getElementById('rows').value=ij.x;
    // document.getElementById('columns').value=ij.y;
  })
  const DIMS=['x','y'];
  const FT=DIMS.map(dim => Array.from({length:50},(_,i)=>({dim,n:i+5,period:1/(i+5),scale:Math.PI*2*(i+5),x:0,y:0})));
  for(let y=0;y<size.y;++y){
    for(let x=0;x<size.x;++x){
      const pos=xy2pos(x,y);
      const e = data[pos+0];
      const ij=toIJ(simple.A_inv,{x,y});
      if(0<=ij.x && ij.x <=1 && 0<=ij.y && ij.y<=1){
        DIMS.forEach((dim,i)=>{
          FT[i].forEach(hypothesis=>{
            const a= ij[dim]*hypothesis.scale;
            hypothesis.x += Math.cos(a)*e;
            // hypothesis.y += Math.sin(a)*e;
          })
        })
      } 
    }
  }
  const [x,y]=DIMS.map((dim,i)=>{
    // FT[i].forEach(hypothesis=>{hypothesis.length=length(hypothesis)})
    //Actually, because grid lines on the paper appear at the boundaries of periods,
    //we could use "Discrete Cosine Transform" instead of "Discrete Fourier Transform",
    //in other words, sort by ".x" field, not ".length", and get the same result.
    //This is because `cos` has largest values near 0 and 2PI, and the whole Fourier/length 
    //thing is only really needed when we don't know at what offset the peaks occur.
    //OTOH trying to use .y will lead to disaster, as `sin`'s maximum happens in not useful place.
    // const best=FT[i].sort((a,b)=>b.length-a.length)[0];
    const best=FT[i].sort((a,b)=>b.x-a.x)[0];
    console.log(best);
    return best.n;
  });
  console.log(FT)
  return {x,y};
}
function analyze(){
  const corners=getCorners();
  const gridSize=getGridSize(corners);
  const understanding = understand(gridSize,corners);
  preview.addEventListener('mousemove',(e)=>{
    const p={x:e.offsetX,y:e.offsetY};
    const ij=toIJ(understanding.A_inv,p);

    document.getElementById('rows').value=ij.x;
    document.getElementById('columns').value=ij.y;
  })
  
}

if(photo.complete){
  analyze();
}else{
  photo.addEventListener('load',()=>{
    analyze();
  })
}
  </script>
</html>