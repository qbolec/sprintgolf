<!doctype html>
<html>
  <head>
    <meta charset="utf-8"/>
    <style>
      *{
        box-sizing:border-box;
      }
      body {
        margin:0;
        padding:0;
        background: brown;
      }
      #desktop{
        position: relative;;
        height:600px;  
        width:800px;  
      }
      #preview,
      #photo{
        position: absolute;
        height:100%;  
        width:100%;  
        top:0px;
        left:0px;
      }
      #photo{
        /*display: none;*/
      }
    </style>
  </head>
  <body>
    <div id="desktop">
      <img id="photo" src="labirynt Hugo.jpg"/>
      <canvas id="preview" width="800" height="600"/>
    </div>
    <label for="rows">rows:</label><input type=number id="rows" value=25>
    <label for="columns">columns:</label><input type=number id="columns" value=38>
    <span id="status"></span>
  </body>
  <script type="text/javascript" src="lib.js"></script>
  <script type="text/javascript">

const photo = document.getElementById('photo');
const preview = document.getElementById('preview');
const ctx = preview.getContext('2d');
function drawDot(color,p){
  ctx.strokeStyle=color;
  ctx.beginPath();
  ctx.rect(p.x-1, p.y-1,3,3);
  ctx.stroke();
}
function analyze(){
  ctx.drawImage(
    photo, 
    0, 0, photo.width, photo.height
  );
  const imageData=ctx.getImageData(0,0,preview.width,preview.height);
  const data = imageData.data;
  const cloned = new Uint8ClampedArray(data);
  const get = (x,y) => {
    const pos=y*preview.width*4+4*x;
    const colors = [cloned[pos+0],cloned[pos+1],cloned[pos+2]]
    return colors;
  }
  const WX = [
    [-1, 0, 1],
    [-2, 0, 2],
    [-1, 0, 1],
  ];
  const WY = WX.map((row,i)=>row.map((v,j)=>WX[j][i]))
  const W=[WX,WY];
  const es = [];
  const xy2pos = (x,y)=>(y*preview.width+x)*4;
  for(let y=1;y+1<preview.height;++y){
    for(let x=1;x+1<preview.width;++x){
      const pos=xy2pos(x,y);
      let L=[[0,0,0],[0,0,0]];
      for(let dx=-1;dx<=1;++dx){
        for(let dy=-1;dy<=1;++dy){
          const n=get(x+dx,y+dy);
          W.forEach((w,i)=>{
            const s=w[1+dy][1+dx];
            n.forEach((v,j)=> {L[i][j]+=s*v})
          })
        }
      }
      const e = max(L[0].map((l,i)=> Math.sqrt(l**2+L[1][i]**2)) );
      es.push(e);
      for(let i=0;i<3;++i){
        data[pos+i]=e;
      }
    }
  }
  const threshold = split(es).threshold;
  for(let y=1;y+1<preview.height;++y){
    for(let x=1;x+1<preview.width;++x){
      const pos=xy2pos(x,y);
      for(let i=0;i<3;++i){
        data[pos+i]=data[pos+i]>threshold?255:0;
      } 
    }
  }

  let todo=[];
  for(let y=preview.height>>2;y<preview.height*3>>2;++y){
    for(let x=preview.width>>2;x<preview.width*3>>2;++x){
      const pos=xy2pos(x,y);
      if(data[pos+0]){
        data[pos+1]=0;
        todo.push({x,y});
      }
    }
  }

  let min_x = Array.from({length:preview.height},()=>+Infinity)
  let max_x = Array.from({length:preview.height},()=>-Infinity)
  let min_y = Array.from({length:preview.width},()=>+Infinity)
  let max_y = Array.from({length:preview.width},()=>-Infinity)
  while(todo.length){
    const {x,y}=todo.pop();
    if(x<min_x[y])min_x[y]=x;
    if(max_x[y]<x)max_x[y]=x;
    if(y<min_y[x])min_y[x]=y;
    if(max_y[x]<y)max_y[x]=y;
    for(let dx=-2;dx<=2;++dx){
      const x2=x+dx;
      if(0<=x2 && x2<preview.width){
        for(let dy=-2;dy<=2;++dy){
          const y2=y+dy;
          if(0<=y2 && y2<preview.height){
            const pos=xy2pos(x2,y2);
            if(data[pos+0]&&data[pos+1]){
              data[pos+1]=0;
              todo.push({x:x2,y:y2});
            }
          }
        }
      }
    }
  }
  const border=[];
  const submit=(x,y)=>{
    const pos = xy2pos(x,y);
    if(data[pos+2]){
      data[pos+2]=0;
      border.push({x,y});
    }
  }
  min_x.forEach((x,y)=>{if(x!=+Infinity){submit(x,y)}})
  max_x.forEach((x,y)=>{if(x!=-Infinity){submit(x,y)}})
  min_y.forEach((y,x)=>{if(y!=+Infinity){submit(x,y)}})
  max_y.forEach((y,x)=>{if(y!=-Infinity){submit(x,y)}})
  for(let y=1;y+1<preview.height;++y){
    for(let x=1;x+1<preview.width;++x){
      const pos=xy2pos(x,y);
      if(!data[pos+0]||data[pos+1]||data[pos+2]){
        data[pos+0]=data[pos+1]=data[pos+2]=0;
      }
    }
  }
  console.log(border.length);
  border.sort((a,b)=> Math.atan2(a.y-preview.height/2,a.x-preview.width/2)-Math.atan2(b.y-preview.height/2,b.x-preview.width/2))
  const diagonal=Math.sqrt(preview.width**2+preview.height**2);
  const lowest=-preview.width;
  const highest=diagonal;
  const span=highest-lowest;
  const huogh=Array.from({length:180},(_,i)=>{
    const a=Math.PI*i/180;
    const c=Math.cos(a);
    const s=Math.sin(a);
    const shadows=Array.from({length:span},()=>0)
    border.forEach(({x,y})=>{
      const projection=x*c+y*s;
      console.assert(lowest<=projection && projection<=highest); 
      shadows[Math.round(projection)  - lowest]++;
    })
    return shadows;
  })
  for(let y=0;y<preview.height;++y){
    for(let x=0;x<preview.width;++x){
      const pos=xy2pos(x,y);
      data[pos+2]=huogh[Math.floor(y*180/preview.height)][Math.floor(x*span/preview.width)]
    }
  }
  //TODO: when the angle wraprs over 180 degrees, the offset should become negative, and so it's not the same!
  const localOptima=[];
  const mirrorOff = (off) => -(off+lowest)-lowest;
  {
    const DEG_DIFF=3;
    const OFF_DIFF=5;
    huogh.forEach((offsets,deg)=>offsets.forEach((cnt,off)=>{
      if(cnt<2){
        return;
      }
      for(let dd=-DEG_DIFF;dd<=DEG_DIFF;++dd){
        let deg2=deg+dd;
        let mirror=false;
        if(deg2<0){
          deg2+=180;
          mirror=true;
        }
        if(180<=deg2){
          deg2-=180;
          mirror=true;
        }
        for(let doff=-OFF_DIFF;doff<=OFF_DIFF;++doff){
          let off2=off+doff;
          if(mirror){
            off2=mirrorOff(off2);
          }
          if(0<=off2 && off2<span){
            if(cnt<huogh[deg2][off2]){
              return;
            }
          }
        }
      }
      localOptima.push({deg,off,cnt});
    }))
  }
  localOptima.sort((a,b)=>a.cnt-b.cnt)
  let sides=[];
  for(let i=0;i<4;++i){
    do{
      const best=localOptima.pop();
      if(sides.some((v)=> {
        let degDiff=Math.abs(v.deg-best.deg);
        let offDiff=Math.abs(v.off-best.off);
        if(degDiff>90){
          degDiff=180-degDiff;
          offDiff=Math.abs(v.off-mirrorOff(best.off))
        }
        return degDiff < 10 && offDiff<10
      })){
        continue;
      }
      const a=Math.PI*best.deg/180;
      sides.push({
        off:best.off+lowest,
        a,
        y:Math.sin(a),
        x:Math.cos(a),
      });
    }while(false)
  }
  console.log(sides);
  for(let y=0;y<preview.height;++y){
    for(let x=0;x<preview.width;++x){
      if(sides.some((side)=> Math.abs(x*side.x+y*side.y-side.off)<1)){
        const pos=xy2pos(x,y);
        // data[pos+1]=255;
      }
    }
  }
  for(let iter=0;iter<3;++iter){
    let sidesSamples=sides.map(()=>[])
    border.forEach(({x,y})=>{
      const nearestI=sides.map((side,i)=> [Math.abs(x*side.x+y*side.y-side.off),i]).sort((a,b)=>a[0]-b[0])[0][1];
      sidesSamples[nearestI].push(({x,y}));
      const pos=xy2pos(x,y);
      const color=[[255,255,255],[255,0,0],[0,255,255],[255,0,255]][nearestI];
      for(let i=0;i<3;++i)data[pos+i]=color[i];
    })
    const newSides=sidesSamples.map(optimalLine);
    console.log(`refining ${iter}`)
    newSides.forEach((newSide,i)=>{
      console.log(`${newSide.a} ${newSide.off} was ${sides[i].a} ${sides[i].off}`);
    })
    sides=newSides; 
  }
  const center={x:preview.width/2,y:preview.height/2};
  sides=sides.map(side=>{
    const off=side.off-scalar(side,center)
    const a = off<0 ? side.a+Math.PI: side.a;
    return [a,side];
  }).sort((a,b)=>a[0]-b[0]).map(a=>a[1])

  for(let y=0;y<preview.height;++y){
    for(let x=0;x<preview.width;++x){
      const nearestI=sides.findIndex((side)=> Math.abs(x*side.x+y*side.y-side.off)<1);
      if(-1<nearestI){
        const pos=xy2pos(x,y);
        const color=[[255,255,255],[255,0,0],[0,255,255],[255,0,255]][nearestI];
        for(let i=0;i<3;++i)data[pos+i]=color[i];
      }
    }
  }
  const corners=sides.map((side,i)=>{
    const next=sides[i+1&3];
    // x * side.x + y * side.y = side.off
    // x * next.x + y * next.y = next.off
    const A = [
      [side.x, side.y],
      [next.x, next.y],
    ];
    const b = [
      side.off,
      next.off,
    ];
    const [x,y]=solve(A,b);
    return {x,y};
  });
  ctx.putImageData(imageData,0,0);
  corners.forEach(corner=>{
    drawDot('green',corner);
  });

}
photo.addEventListener('load',()=>{
  analyze();
})
  </script>
</html>