<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    *{
      box-sizing:border-box;
    }
    body {
      margin:0;
      padding:0;
      background: black;
    }
    #arena {
      background: #750202;
      transition: transform 1s;
      margin: 30px;
      position: relative;
    }
    #arena.ArrowUp{
      transform: perspective(500px) rotateX(10deg)
    }
    #arena.ArrowDown{
      transform: perspective(500px) rotateX(-10deg)
    }
    #arena.ArrowLeft{
      transform: perspective(500px) rotateY(-10deg)
    }
    #arena.ArrowRight{
      transform: perspective(500px) rotateY(10deg)
    }
    .box {
      background: white;
      position: absolute;
    }
    #ball {
      width: 20px;
      height: 20px;
      background: radial-gradient(circle at 30% 30%, white, black);
      border-radius:50%;
      position: absolute;
      left: 0px;
    }
    #collision::after {
      content: " ";
      display: block;
      background: yellow;
      width: 1px;
      height: 10px;
      left: 9px;
      position: relative;
    }
    #collision {
      width: 20px;
      height: 20px;
      background: transparent;
      border-radius:50%;
      border:1px solid white;
      position: absolute;
      left: 0px;
    }
  </style>
</head>


<body>
  <audio src="ping.ogg"></audio>
  <audio src="ping.ogg"></audio>
  <audio src="ping.ogg"></audio>
  <div id="arena">
  <div id="ball"></div>
  <div id="collision"></div>
  </div>
</body>

<script>
  let ballElement = document.getElementById('ball');
  let audioElements = document.querySelectorAll('audio');
  let nextAudioElementIdx = 0;
  let ballModel = {
    r:10,
    p: {
      x: 10,
      y: 10,
    },
    v: {
      x: 10,
      y: 10,
    },
    a: {
      x:0,
      y:2,
    }
  };
  const HEIGHT = 550;
  const WIDTH = 550;
  const boxes = [
    //bottom
    {min:{x:0,y:HEIGHT},max:{x:WIDTH,y:HEIGHT+10}},
    // pierwsza kreska Hugo:
    {min:{x:50,y:100},max:{x:100,y:110}},
    // druga:
    {min:{x:150,y:100},max:{x:400,y:110}},
    //top:
    {min:{x:0,y:-10},max:{x:WIDTH,y:0}},
    //left:
    {min:{x:-10,y:0},max:{x:0,y:HEIGHT}},
    //right:
    {min:{x:WIDTH,y:0},max:{x:WIDTH+10,y:HEIGHT}},
    //something:
    {min:{x:100,y:100},max:{x:110,y:200}},
    {min:{x:300,y:0},max:{x:310,y:50}},
  ];
  const arena=    document.getElementById('arena');
  arena.style.height =HEIGHT  + 'px';
  arena.style.width =WIDTH  + 'px';
  boxes.forEach(box => {
    const boxElement=document.createElement('div');
    boxElement.className='box';
    boxElement.style.left = box.min.x + 'px';
    boxElement.style.top = box.min.y + 'px';
    boxElement.style.width = box.max.x-box.min.x + 'px';
    boxElement.style.height = box.max.y-box.min.y + 'px';
    document.getElementById('arena').appendChild(boxElement);
  })
  setInterval(() => {
    
      //nextCollisionWith({"r":20,"p":{"x":20,"y":20},"v":{"x":10,"y":10},"a":{"x":0,"y":2}},{"min":{"x":0,"y":200},"max":{"x":1000,"y":210}});
      //zeros([40,10,0])
      //zeros([10,0])
    let t = 1;
    function advance(t){
      if(WIDTH<plus(plus(ballModel.p, scale(t,ballModel.v)), scale(t*t/2,ballModel.a)).x){
        debugger;
      }
      ballModel.p = plus(plus(ballModel.p, scale(t,ballModel.v)), scale(t*t/2,ballModel.a));
      ballModel.v = plus(ballModel.v, scale(t,ballModel.a));
      ['x','y'].forEach(d=>{if(!zign(ballModel.v[d])){
        ballModel.v[d]=0
      }});
    }
    const originalAcceleration = ballModel.a;
    for(let i=0;i<1000&&0<t;++i){
      const collision = boxes.map(box => nextCollisionWith(ballModel, box)).filter(c=>c).sort((a,b)=>a.t-b.t)[0];
      const collisionElement = document.getElementById('collision')
      if(collision){
        collisionElement.style.left = collision.f.p.x - collision.f.r + 'px';
        collisionElement.style.top = collision.f.p.y - collision.f.r + 'px';
        collisionElement.style.display='block';
        collisionElement.style.transform=`rotate(${Math.atan2(collision.normal.y,collision.normal.x)+Math.PI/2}rad)`;
      }else{
        collisionElement.style.display='none';
      }
      if(collision && 0<=collision.t && collision.t <= t){
        const delta=collision.t;
        advance(delta);
        if(10<i){
          //ok, this is getting problematic...
          //let's pretend there's no acceleration for a moment
          ballModel.a = {x:0,y:0};
        }
        const e=scalar(collision.normal,ballModel.v)
        if(e<0){
          const energy = -e
          const audioElement = audioElements[nextAudioElementIdx++%audioElements.length];
          audioElement.pause()
          audioElement.currentTime = 0.2;
          audioElement.volume = Math.min(energy/100,1.0);
          audioElement.play();
          const spring = 1.5;
          ballModel.v = plus(ballModel.v, scale(-e*spring, collision.normal));
        }else{
          console.log("wrongly filtered collision?",collision)
        }
        t-= delta;
      }else{
        advance(t);
        t-=t;
      }
      if(i==999){
        debugger;
      }
    }
    ballModel.a=originalAcceleration;
    ballElement.style.left = ballModel.p.x - ballModel.r +"px";
    ballElement.style.top = ballModel.p.y - ballModel.r +"px";
  },20)
function evaluate(a,x){
  if(!Number.isFinite(x)){
    return a.at(-1)*(x**(a.length-1));
  }
  return a.reduce((acc,v,i)=>acc+v*(x**i),0);
}
function zign(x){
  return x<-1e-9?-1:1e-9<x?1:0;
}
function bisect_zero(a,min,max){
  const increasing = evaluate(a,min)<=evaluate(a,max);
  const larger = (x,dir) => (Math.abs(x)*2+1)*Math.sign(dir);
  const split = (min,max)=>Number.isFinite(min)?
      (Number.isFinite(max) ? (max+min)*0.5: larger(min,max)):
      (Number.isFinite(max) ? larger(max,min) : 0);
  for(let i=0;i<10000;++i){
    const mid=split(min,max);
    const val=evaluate(a,mid);
    if(!zign(val)){
      return mid;
    }
    if((val<=0) == increasing ){
      min=mid;
    }else{
      max=mid;
    }
    if(i==10000-1){
      debugger;
    }
  }
  return min;
}
function derivative(a){
  return a.slice(1).map((v,k)=>(k+1)*v)
}
function zeros(a){
  while(a.length && !a.at(-1))a.pop()
  if(!a.length){
    return [0];
  }
  if(a.length==1){
    return a[0]?[]:[0];
  }
  const found=[];
  [-Infinity,...zeros(derivative(a)),+Infinity].forEach((x,i,xs)=>{
    if(i&&zign(evaluate(a,x))!=zign(evaluate(a,xs[i-1]))){
      found.push(bisect_zero(a,xs[i-1],x));
    }
  })
  return found;
}
const plus = (a,b) => ({x:a.x+b.x,y:a.y+b.y});
const minus = (a,b) => ({x:a.x-b.x,y:a.y-b.y});
const scale = (s,p) => ({x:s*p.x,y:s*p.y});
const scalar = (a,b) => a.x*b.x + a.y*b.y;
const always = (x) => () => x;
const length = p => Math.sqrt(p.x**2 + p.y**2)
const distance = (a,b) => length(minus(a,b));
const normalize = p => scale(1.0/length(p),p);
function nextCollisionWith({r,p,v,a},box){
  const future = t => ({r:r,a:a,v:plus(v,scale(t,a)), p:plus(plus(p, scale(t,v) ), scale(t*t/2,a) )})
  let collision = null;
  function check(eq,hit,state2normal){
    zeros(eq).filter(t => 0<=t).forEach(t => {
      const f = future(t);
      if(hit(f)){
        const normal = state2normal(f)
        if(scalar(f.v,normal)<0){
          if(!collision || t<collision.t){
            collision = {t,f,normal};
          }
        }
      }
    })
  }
  check([p.x+r-box.min.x, v.x, a.x/2],({p})=>box.min.y<=p.y && p.y<=box.max.y,always({x:-1,y:0}));
  check([p.x-r-box.max.x, v.x, a.x/2],({p})=>box.min.y<=p.y && p.y<=box.max.y,always({x:+1,y:0}));
  check([p.y+r-box.min.y, v.y, a.y/2],({p})=>box.min.x<=p.x && p.x<=box.max.x,always({x:0,y:-1}));
  check([p.y-r-box.max.y, v.y, a.y/2],({p})=>box.min.x<=p.x && p.x<=box.max.x,always({x:0,y:+1}));
  // Poniżej znajduje się wyprowadzenie wzoru na równanie 4tego stopnia opisujące kolizję kulki z narożnikiem.
  //  ((p.x+v.x*t+a.x/2*tt)-c.x)**2 + ...  = r*r
  //  ((p.x-c.x)+v.x*t+a.x/2*tt)**2 + ...  = r*r
  //  (p.x-c.x)**2  + v.x**2*tt +(a.x/2)**2*tttt + 2(p.x-c.x)*v.x*t + 2(p.x-c.x)*a.x/2*tt + 2*v.x*a.x/2*ttt +     ...  = r*r
  [box.min.x,box.max.x].forEach(cx =>
    [box.min.y,box.max.y].forEach(cy =>{
      const c = {x:cx,y:cy};
      const o = minus(p,c);
      const by_d=['x','y'].map(d => [o[d]**2, 2*o[d]*v[d], v[d]**2+o[d]*a[d],v[d]*a[d],(a[d]/2)**2]);
      const eq = by_d[0].map((v,i)=>v+by_d[1][i]);
      eq[0]-=r*r;
      check(eq, always(true), f => {
        const d=distance(f.p,c);
        if(zign(d-r)){
          console.log("wrong distance on corner collision",d);
        }
        return normalize(minus(f.p,c))
      });
    })
  );
  return collision;
}
document.body.addEventListener('keydown',e => {
  const acc={
    'ArrowUp'   : {x: 0, y:-1},
    'ArrowDown' : {x: 0, y: 1},
    'ArrowLeft' : {x:-1, y: 0},
    'ArrowRight': {x: 1, y: 0},
  }[e.key];
  if(acc){
    ballModel.a=acc;
    document.getElementById('arena').className=e.key;
  }
})
</script>
</html>