<!doctype html>
<html char>
<head>
  <meta charset="utf-8">
  <style>
    body {
      margin:0;
      padding:0;
      background: black;
    }
    #arena {
      background: #750202;
      height: 200px;
      width: 1000px;

    }
    #ball {
      width: 20px;
      height: 20px;
      background: radial-gradient(circle at 30% 30%, white, black);
      border-radius:50%;
      position: absolute;
      left: 0px;
    }
    #collision {
      width: 20px;
      height: 20px;
      background: white;
      border-radius:50%;
      position: absolute;
      left: 0px;
    }
  </style>
</head>


<body>
  <audio src="ping.ogg"></audio>
  <audio src="ping.ogg"></audio>
  <audio src="ping.ogg"></audio>
  <div id="arena">
  <div id="ball"></div>
  <div id="collision"></div>
  </div>
</body>

<script>
  let ballElement = document.getElementById('ball');
  let audioElements = document.querySelectorAll('audio');
  let nextAudioElementIdx = 0;
  let ballModel = {
    radius:10,
    position: {
      x: 10,
      y: 10,
    },
    velocity: {
      x: 10,
      y: 10,
    }
  };
  const HEIGHT = 200;
  const WIDTH = 1000;
  setInterval(() => {
    ballModel.position.x += ballModel.velocity.x;
    ballModel.position.y += ballModel.velocity.y;
    let collision = false;
    if(ballModel.position.y + ballModel.radius > HEIGHT){
      ballModel.position.y -= ballModel.velocity.y;
      ballModel.velocity.y *= -1;
      collision = true;
    }
    if(ballModel.position.y - ballModel.radius< 0){
      ballModel.position.y -= ballModel.velocity.y;
      ballModel.velocity.y *= -1;
      collision = true;
    }

    if(ballModel.position.x + ballModel.radius > WIDTH){
      ballModel.position.x -= ballModel.velocity.x;
      ballModel.velocity.x *= -1;
      collision = true;
    }
    if(ballModel.position.x - ballModel.radius< 0){
      ballModel.position.x -= ballModel.velocity.x;
      ballModel.velocity.x *= -1;
      collision = true;
    }
    if(collision){
      const spring = 0.9;
      const energy = ballModel.velocity.x**2 + ballModel.velocity.y**2

      const audioElement = audioElements[nextAudioElementIdx++%audioElements.length];
      audioElement.pause()
      audioElement.currentTime = 0.2;
      audioElement.volume = Math.min(energy/1000,1.0);
      audioElement.play()
      ballModel.velocity.x *=spring;
      ballModel.velocity.y *=spring;
    }
    
    ballElement.style.left = ballModel.position.x - ballModel.radius +"px";
    ballElement.style.top = ballModel.position.y - ballModel.radius +"px";
    ballModel.velocity.y += 2;
    {/*
      const collision=nextCollisionWith({r:20, p:ballModel.position, v:ballModel.velocity, a:{x:0,y:2}}, {min:{x:0,y:HEIGHT},max:{x:WIDTH,y:HEIGHT+10}});
      const collisionElement = document.getElementById('collision')
      if(collision){
        collisionElement.style.left = collision.f.p.x + 'px';
        collisionElement.style.top = collision.f.p.y + 'px';
        collisionElement.style.display='block';
      }else{
        collisionElement.style.display='none';
      }
    */}

  },20)
function evaluate(a,x){
  if(!Number.isFinite(x)){
    return a.at(-1)*(x**(a.length-1));
  }
  return a.reduce((acc,v,i)=>acc+v*(x**i),0);
}
function zign(x){
  return x<-1e-19?-1:1e-19<x?1:0;
}
function bisect_zero(a,min,max){
  const increasing = evaluate(a,min)<=evaluate(a,max);
  const larger = (x,dir) => (Math.abs(x)*2+1)*Math.sign(dir);
  const split = (min,max)=>Number.isFinite(min)?
      (Number.isFinite(max) ? (max+min)*0.5: larger(min,max)):
      (Number.isFinite(max) ? larger(max,min) : 0);
  while(true){
    const mid=split(min,max);
    const val=evaluate(a,mid);
    if(!zign(val)){
      return mid;
    }
    if((val<=0) == increasing ){
      min=mid;
    }else{
      max=mid;
    }
  }
  return min;
}
function derivative(a){
  return a.slice(1).map((v,k)=>(k+1)*v)
}
function zeros(a){
  if(!a.length){
    return [0];
  }
  if(a.length==1){
    return a[0]?[]:[0];
  }
  const found=[];
  [-Infinity,...zeros(derivative(a)),+Infinity].forEach((x,i,xs)=>{
    if(i&&zign(evaluate(a,x))!=zign(evaluate(a,xs[i-1]))){
      found.push(bisect_zero(a,xs[i-1],x));
    }
  })
  return found;
}
const plus = (a,b) => ({x:a.x+b.x,y:a.y+b.y});
const minus = (a,b) => ({x:a.x-b.x,y:a.y-b.y});
const scale = (s,p) => ({x:s*p.x,y:s*p.y});
const scalar = (a,b) => a.x*b.x + a.y*b.y;
const always = (x) => () => x;
const length = p => Math.sqrt(p.x**2 + p.y**2)
const normalize = p => scale(1.0/length(p),p);
function nextCollisionWith({r,p,v,a},box){
  const future = t => ({r:r,a:a,v:plus(v,scale(t,a)), p:plus(plus(p, scale(t,s) ), scale(t*t/2,a) )})
  const collision = null;
  function check(eq,hit,state2normal){
    zeros(eq).filter(t => 0<=zign(t)).forEach(t => {
      const f = future(t);
      if(hit(f)){
        const normal = state2normal(f)
        if(scalar(f.v,normal)<0){
          if(!collision || t<collision.t){
            collision = {t,f,normal}
          }
        }
      }
    })
  }
  check([p.x+r-box.min.x, v.x, a.x/2],({p})=>box.min.y<=p.y && p.y<=box.max.y,always({x:-1,y:0}))
  check([p.x-r-box.max.x, v.x, a.x/2],({p})=>box.min.y<=p.y && p.y<=box.max.y,always({x:+1,y:0}))
  check([p.y+r-box.min.y, v.y, a.y/2],({p})=>box.min.x<=p.x && p.x<=box.max.x,always({x:0,y:-1}))
  check([p.y-r-box.max.y, v.y, a.y/2],({p})=>box.min.x<=p.x && p.x<=box.max.x,always({x:0,y:+1}))
  //  ((p.x+v.x*t+a.x/2*tt)-c.x)**2 + ...  = r*r
  //  ((p.x-c.x)+v.x*t+a.x/2*tt)**2 + ...  = r*r
  //  (p.x-c.x)**2  + v.x**2*tt +(a.x/2)**2*tttt + 2(p.x-c.x)*v.x*t + 2(p.x-c.x)*a.x/2*tt + 2*v.x*a.x/2*ttt +     ...  = r*r
  [box.min.x,box.max.x].forEach(cx =>
    [box.min.y,box.max.y].forEach(cy =>{
      const c = {x:cx,y:cy}
      const o = minus(p,c)
      const by_d=['x','y'].map(d => [o[d]**2, 2*o[d]*s[d], s[d]**2+o[d]*a[d],s[d]*a[d],(a[d]/2)**2]);
      const eq = by_d[0].map((v,i)=>v+by_d[1][i])
      eq[0]-=r*r;
      check(eq, always(true), f => normalize(minus(f.p,c)))
    })
  )
  return collision;
}
</script>
</html>